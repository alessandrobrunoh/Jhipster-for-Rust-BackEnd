use serde::{Deserialize, Serialize};
use domain::domain::user::UserId;
use domain::domain::truck::TruckId;

{% if orm == "sqlx" %}
use sqlx::FromRow;
{% elif orm == "diesel" %}
use diesel::prelude::*;
use super::schema::{users, trucks}; // Assuming schema.rs is generated by Diesel CLI
{% elif orm == "seaorm" %}
use sea_orm::entity::prelude::*;
use sea_orm::{Set, TryIntoModel, IntoActiveModel};
{% endif %}

{% if orm == "sqlx" %}
#[derive(Debug, Clone, PartialEq, FromRow, Serialize, Deserialize)]
pub struct UserDb {
    pub id: i64, // Use i64 for SQLx ID
    pub username: String,
    pub email: String,
    pub password_hash: String,
}

#[derive(Debug, Clone, PartialEq, FromRow, Serialize, Deserialize)]
pub struct TruckDb {
    pub id: i64, // Use i64 for SQLx ID
    pub license_plate: String,
    pub capacity: f32,
}
{% elif orm == "diesel" %}
#[derive(Debug, Clone, PartialEq, Queryable, Selectable, Insertable, AsChangeset, Serialize, Deserialize)]
#[diesel(table_name = users)]
pub struct UserDb {
    pub id: i64,
    pub username: String,
    pub email: String,
    pub password_hash: String,
}

#[derive(Debug, Clone, PartialEq, Queryable, Selectable, Insertable, AsChangeset, Serialize, Deserialize)]
#[diesel(table_name = trucks)]
pub struct TruckDb {
    pub id: i64,
    pub license_plate: String,
    pub capacity: f32,
}

// Diesel has a separate schema.rs file generated by the CLI.
// For example:
// diesel::table! {
//     users (id) {
//         id -> Int8,
//         username -> Varchar,
//         email -> Varchar,
//         password_hash -> Varchar,
//     }
// }
//
// diesel::table! {
//     trucks (id) {
//         id -> Int8,
//         license_plate -> Varchar,
//         capacity -> Float4,
//     }
// }

{% elif orm == "seaorm" %}
// ============= USERS ENTITY =============
pub mod users {
    use super::*;

    #[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel, Serialize, Deserialize)]
    #[sea_orm(table_name = "users")]
    pub struct Model {
        #[sea_orm(primary_key)]
        pub id: i64,
        pub username: String,
        pub email: String,
        pub password_hash: String,
    }

    #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
    pub enum Relation {}

    impl ActiveModelBehavior for ActiveModel {}
}

// ============= TRUCKS ENTITY =============
pub mod trucks {
    use super::*;

    #[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
    #[sea_orm(table_name = "trucks")]
    pub struct Model {
        #[sea_orm(primary_key)]
        pub id: i64,
        pub license_plate: String,
        pub capacity: f32,
    }

    #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
    pub enum Relation {}

    impl ActiveModelBehavior for ActiveModel {}
}

// Type aliases for easier use
pub type UserEntity = users::Entity;
pub type UserModel = users::Model;
pub type UserActiveModel = users::ActiveModel;

pub type TruckEntity = trucks::Entity;
pub type TruckModel = trucks::Model;
pub type TruckActiveModel = trucks::ActiveModel;

{% elif database == "mongodb" %}
use mongodb::bson::oid::ObjectId;
use mongodb::bson::DateTime;

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct UserDb {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub username: String,
    pub email: String,
    pub password_hash: String,
    pub created_at: DateTime,
    pub updated_at: DateTime,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TruckDb {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub license_plate: String,
    pub capacity: f32,
    pub created_at: DateTime,
    pub updated_at: DateTime,
}
{% endif %}


// From/Into conversion to domain::domain
{% if orm == "sqlx" or orm == "diesel" or database == "mongodb" %}
impl From<UserDb> for domain::domain::user::User {
    fn from(db_user: UserDb) -> Self {
        domain::domain::user::User::new(UserId(db_user.id as u64), db_user.username, db_user.email)
    }
}

impl From<TruckDb> for domain::domain::truck::Truck {
    fn from(db_truck: TruckDb) -> Self {
        domain::domain::truck::Truck::new(TruckId(db_truck.id as u64), db_truck.license_plate, db_truck.capacity)
    }
}

// For creating new users in DB (without ID)
pub struct NewUserDb {
    pub username: String,
    pub email: String,
    pub password_hash: String,
}

impl From<domain::domain::user::User> for NewUserDb {
    fn from(user: domain::domain::user::User) -> Self {
        NewUserDb {
            username: user.username,
            email: user.email,
            password_hash: "".to_string(), // Password hash must be provided by application layer
        }
    }
}

pub struct NewTruckDb {
    pub license_plate: String,
    pub capacity: f32,
}

impl From<domain::domain::truck::Truck> for NewTruckDb {
    fn from(truck: domain::domain::truck::Truck) -> Self {
        NewTruckDb {
            license_plate: truck.license_plate,
            capacity: truck.capacity,
        }
    }
}

{% elif orm == "seaorm" %}
impl From<UserModel> for domain::domain::user::User {
    fn from(db_user: UserModel) -> Self {
        domain::domain::user::User::new(UserId(db_user.id as u64), db_user.username, db_user.email)
    }
}

impl From<domain::domain::user::User> for UserActiveModel {
    fn from(user: domain::domain::user::User) -> Self {
        UserActiveModel {
            id: Set(user.id.0 as i64),
            username: Set(user.username),
            email: Set(user.email),
            password_hash: Set("".to_string()), // Password hash must be provided by application layer
        }
    }
}

impl From<TruckModel> for domain::domain::truck::Truck {
    fn from(db_truck: TruckModel) -> Self {
        domain::domain::truck::Truck::new(TruckId(db_truck.id as u64), db_truck.license_plate, db_truck.capacity)
    }
}

impl From<domain::domain::truck::Truck> for TruckActiveModel {
    fn from(truck: domain::domain::truck::Truck) -> Self {
        TruckActiveModel {
            id: Set(truck.id.0 as i64),
            license_plate: Set(truck.license_plate),
            capacity: Set(truck.capacity),
        }
    }
}
{% endif %}
