use axum::{
    routing::{get, post},
    Router,
    Json,
    extract::State,
    http::StatusCode,
};
use crate::config::AppState;
use crate::domain::truck::{Truck, NewTruck};
use crate::service::truck_service::TruckService;
use crate::repository::truck_repository::TruckRepositoryImpl;
use std::sync::Arc;

pub fn router() -> Router<AppState> {
    Router::new()
        .route("/trucks", get(list_trucks).post(create_truck))
}

/// List all trucks
#[utoipa::path(
    get,
    path = "/api/trucks",
    responses(
        (status = 200, description = "List of trucks", body = Vec<Truck>)
    )
)]
async fn list_trucks(State(state): State<AppState>) -> Json<Vec<Truck>> {
    let repo = Arc::new(TruckRepositoryImpl { pool: state.db.clone() });
    let service = TruckService { repo };
    
    match service.get_all_trucks().await {
        Ok(trucks) => Json(trucks),
        Err(_) => Json(vec![]), // Handle error properly
    }
}

/// Create a new truck
#[utoipa::path(
    post,
    path = "/api/trucks",
    request_body = NewTruck,
    responses(
        (status = 201, description = "Truck created", body = Truck)
    )
)]
async fn create_truck(
    State(state): State<AppState>,
    Json(payload): Json<NewTruck>,
) -> (StatusCode, Json<Option<Truck>>) {
    let repo = Arc::new(TruckRepositoryImpl { pool: state.db.clone() });
    let service = TruckService { repo };

    match service.create_truck(payload).await {
        Ok(truck) => (StatusCode::CREATED, Json(Some(truck))),
        Err(_) => (StatusCode::INTERNAL_SERVER_ERROR, Json(None)),
    }
}
