use axum::{
    extract::State,
    Json,
    http::StatusCode,
    Router,
    routing::{get, post},
};
use crate::di::app_state::AppState;
use crate::error::AppError;
use crate::dto::user_requests::{RegisterUserRequest, UserResponse};
use validator::Validate;
use std::sync::Arc;

#[utoipa::path(
    post,
    path = "/api/users",
    request_body = RegisterUserRequest,
    responses(
        (status = 201, description = "User registered successfully", body = UserResponse),
        (status = 400, description = "Bad Request", body = AppError),
        (status = 500, description = "Internal Server Error", body = AppError)
    ),
    tag = "User"
)]
pub async fn register_user(
    State(app_state): State<Arc<AppState>>,
    Json(payload): Json<RegisterUserRequest>,
) -> Result<(StatusCode, Json<UserResponse>), AppError> {
    payload.validate()?;
    let command = payload.into();
    let user = app_state.user_service.register_user(command).await?;
    Ok((StatusCode::CREATED, Json(user.into())))
}

#[utoipa::path(
    get,
    path = "/api/users",
    responses(
        (status = 200, description = "List of all users", body = Vec<UserResponse>),
        (status = 500, description = "Internal Server Error", body = AppError)
    ),
    tag = "User"
)]
pub async fn get_all_users(
    State(app_state): State<Arc<AppState>>,
) -> Result<Json<Vec<UserResponse>>, AppError> {
    // Placeholder - implement get_all_users in UserService if needed
    let user_profile = app_state.user_service.get_user_profile(domain::domain::user::UserId(1)).await?;
    Ok(Json(vec![user_profile.into()]))
}

pub fn create_routes(app_state: Arc<AppState>) -> Router {
    Router::new()
        .route("/api/users", post(register_user))
        .route("/api/users", get(get_all_users))
        .with_state(app_state)
}
